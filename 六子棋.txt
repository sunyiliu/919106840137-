rjdzyjs.cpp中
#include<QMenuBar>
#include<QPainter>
#include"mypushbutton.h"
#include<QTimer>
#include<QMouseEvent>
#include<math.h>
#include"gamemodel.h"
#include<QDebug>
#include<QMessageBox>
#include<QSound>
rjdzyjs::rjdzyjs(QWidget *parent) : QMainWindow(parent)
{
     setMouseTracking(true);
    //配置基本信息
   this->setFixedSize(1406,1200);
   //设置图标
   this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
   //设置标题
   this->setWindowTitle("人机对战（有禁手）");
    //创建菜单栏
    QMenuBar *bar3 = menuBar();
    setMenuBar(bar3);
    //创建开始菜单
    QMenu *startMenu = bar3->addMenu("帮助");
    //创建单项
    QAction * quitAction = startMenu->addAction("退出");
    //点击退出游戏
    connect(quitAction,&QAction::triggered,[=](){
        this->close();
    });
    //返回按钮
    MyPushButton *backBtn = new MyPushButton(":/new/prefix1/res/17.jpg",":/new/prefix1/res/18.jpg");
    backBtn->setParent(this);
    backBtn->move(1300,981);
    //点击返回
    connect(backBtn,&MyPushButton::clicked,[=](){
        if(QMessageBox::Yes == QMessageBox::question(this,"question","确定要退出吗？",QMessageBox::Yes|QMessageBox::No,QMessageBox::No)){
            for(int i=1;i<21;i++){
                for(int j=1;j<21;j++){
                    game->gameMapVec[i][j]=0;
                }
            }
            posrow=0;
            poscol=0;
            posrow_ex=0;
            poscol_ex=0;
            game->playerFlag=true;
            //延迟返回
            QTimer::singleShot(400,this,[=](){
                //返回主场景
                 emit this->chooseSceneBack();
            });
                }
    });
    MyPushButton *backBtn1 = new MyPushButton(":/new/prefix1/res/40.jpg",":/new/prefix1/res/41.jpg");
    backBtn1->setParent(this);
    backBtn1->move(1280,581);
    connect(backBtn1,&MyPushButton::clicked,[=](){
        int n(0);
        for(int row=0;row<21;row++){
            for(int col=0;col<21;col++){
                if(!game->gameMapVec[row][col]==0) n++;
            }
        }
        if(n){
               game->gameMapVec[posrow_ex][poscol_ex]=0;
                game->gameMapVec[posrow][poscol]=0;
                posrow=0;
                poscol=0;
                posrow_ex=0;
                poscol_ex=0;
                update();
        }
    });
     initGame();
}
void rjdzyjs::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/25.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
    painter.setRenderHint(QPainter::Antialiasing,true);
    for(int i=0;i<22;i++){
        //从左到右竖线
        painter.drawLine(55+52*i,55,55+52*i,1146);
        //从上到下横线
        painter.drawLine(55,55+52*i,1146,55+52*i);
    }
    //绘制选中点
    QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        // 绘制落子标记(防止鼠标出框越界)
        if (clickPosRow > 0 && clickPosRow < 21 &&
            clickPosCol > 0 && clickPosCol < 21 &&
            game->gameMapVec[clickPosRow][clickPosCol] == 0)
        {
            if (game->playerFlag)
                brush.setColor(Qt::black);
            else
                brush.setColor(Qt::white);
            painter.setBrush(brush);
            painter.drawRect(55 + 52 * clickPosCol - 6 / 2, 55 + 52 * clickPosRow - 6 / 2, 6, 6);
        }
        //绘制棋子
        for(int i=1;i<21;i++){
            for(int j=1;j<21;j++){
                if(i==posrow_ex&&j==poscol_ex){
                    if(game->gameMapVec[posrow_ex][poscol_ex]==1){
                        brush.setColor(Qt::black);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                    else {
                        brush.setColor(Qt::white);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                }
                else if(game->gameMapVec[i][j]==1){
                    brush.setColor(Qt::black);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
                else if(game->gameMapVec[i][j]==-1){
                    brush.setColor(Qt::white);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
            }
        }
        if (clickPosRow > 0 && clickPosRow < 21 &&
                    clickPosCol > 0 && clickPosCol < 21 &&
               (game->gameMapVec[clickPosRow][clickPosCol] == 1 ||
                        game->gameMapVec[clickPosRow][clickPosCol] == -1))
           {
               if (game->winorlose(clickPosRow, clickPosCol) && game->gameStatus == PLAYING)
               {
                        // qDebug() << "win";
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QString str;
                   if (game->gameMapVec[clickPosRow][clickPosCol] == 1)
                       str = "玩家获胜";
                   else if (game->gameMapVec[clickPosRow][clickPosCol] == -1)
                       str = "电脑获胜";
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", str );
                   // 重置游戏状态，否则容易死循环
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                       posrow_ex=0;
                       poscol_ex=0;
                       posrow=0;
                       poscol=0;
                   }
               }
               else if (game->heqi())
                   {
                       QMessageBox::StandardButton btnValue = QMessageBox::information(this, "啊偶", "和棋了");
                       if (btnValue == QMessageBox::Ok)
                       {
                           game->startGame(game_type);
                           game->gameStatus = PLAYING;
                           posrow_ex=0;
                           poscol_ex=0;
                           posrow=0;
                           poscol=0;
                       }
                   }
               else if (game->gameMapVec[clickPosRow][clickPosCol]==1&& game->nohands(clickPosRow,clickPosCol)){
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", "白棋获胜" );
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                       posrow_ex=0;
                       poscol_ex=0;
                       posrow=0;
                       poscol=0;
                   }
               }
           }
}
void rjdzyjs::initGame(){
    game = new GameModel;//初始化游戏模型
    initAIGame();
}
void rjdzyjs::initAIGame(){
    game_type=AIII;
    game->gameStatus=PLAYING;
    game->startGame(game_type);//在数据模型中进行初始化功能
    update();
}
void rjdzyjs::mouseMoveEvent(QMouseEvent *event)
{
    // 通过鼠标的hover确定落子的标记
    int x = event->x();
    int y = event->y();
    // 棋盘边缘不能落子
    if (x >= 55 +26&&
            x < 1121 &&
            y >= 55+26 &&
            y < 1121)
    {
        // 获取最近的左上角的点
        int col = (x-55) / 52;
        int row = (y-55) / 52;
        int leftTopPosX = 55 + 52 * col;
        int leftTopPosY = 55 + 52 * row;
        // 根据距离算出合适的点击位置,一共四个点，根据半径距离选最近的
        clickPosRow = -1; // 初始化最终的值
        clickPosCol = -1;
        int len = 0; // 计算完后取整就可以了
        selectPos =false;
        // 确定一个误差在范围内的点，且只可能确定一个出来
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
    }
    // 存了坐标后也要重绘
    update();
}
void rjdzyjs::mouseReleaseEvent(QMouseEvent *event){
    if(selectPos == false ){
        return ;
    }
    else{
        selectPos =false;
    }
    chessByPerson();
    if(game_type == AIII){
        QTimer::singleShot(1000, this, [=](){
            chessByAI();
        });
    }
}
void rjdzyjs::chessByPerson(){
    //根据当前存储的坐标落子
    //只有有效点击才下子，并且该处没有子
    if(clickPosRow !=-1&&clickPosCol!=-1&&game->gameMapVec[clickPosRow][clickPosCol]==0){
        QSound *luozi = new QSound(":/new/prefix1/res/123.wav",this);
        luozi->play();
        for(int row=1;row<21;row++){
            for(int col=1;col<21;col++){
                if( game->gameMapVec[row][col]==0){
                    game->gameMapVec[row][col]=3;
                }
            }
        }
        posrow= clickPosRow;
        poscol= clickPosCol;
        game->Person(clickPosRow,clickPosCol);
        //重绘
        update();
    }
    //判断是否胜利
}
void rjdzyjs::chessByAI()
{
    for(int row=1;row<21;row++){
        for(int col=1;col<21;col++){
            if( game->gameMapVec[row][col]==3){
                game->gameMapVec[row][col]=0;
            }
        }
    }
    game->AI(clickPosRow, clickPosCol);
    posrow_ex=clickPosRow;
    poscol_ex=clickPosCol;
   update();
}

rjdzwjs.cpp中
#include<QMenuBar>
#include<QPainter>
#include"mypushbutton.h"
#include<QTimer>
#include<QMouseEvent>
#include<math.h>
#include"gamemodel.h"
#include<QDebug>
#include<QMessageBox>
#include<QSound>
rjdzwjs::rjdzwjs(QWidget *parent) : QMainWindow(parent)
{
     setMouseTracking(true);
    //配置基本信息
   this->setFixedSize(1406,1200);
   //设置图标
   this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
   //设置标题
   this->setWindowTitle("人机对战（无禁手）");
    //创建菜单栏
    QMenuBar *bar4 = menuBar();
    setMenuBar(bar4);
    //创建开始菜单
    QMenu *startMenu = bar4->addMenu("帮助");
    //创建单项
    QAction * quitAction = startMenu->addAction("退出");
    //点击退出游戏
    connect(quitAction,&QAction::triggered,[=](){
        this->close();
    });
    //返回按钮
    MyPushButton *backBtn = new MyPushButton(":/new/prefix1/res/17.jpg",":/new/prefix1/res/18.jpg");
    backBtn->setParent(this);
    backBtn->move(1300,981);
    //点击返回
    connect(backBtn,&MyPushButton::clicked,[=](){
        if(QMessageBox::Yes == QMessageBox::question(this,"question","确定要退出吗？",QMessageBox::Yes|QMessageBox::No,QMessageBox::No)){
            for(int i=1;i<21;i++){
                for(int j=1;j<21;j++){
                    game->gameMapVec[i][j]=0;
                }
            }
            posrow=0;
            poscol=0;
            posrow_ex=0;
            poscol_ex=0;
            game->playerFlag=true;
            //延迟返回
            QTimer::singleShot(400,this,[=](){
                //返回主场景
                 emit this->chooseSceneBack();
            });
                }
    });
    MyPushButton *backBtn1 = new MyPushButton(":/new/prefix1/res/40.jpg",":/new/prefix1/res/41.jpg");
    backBtn1->setParent(this);
    backBtn1->move(1280,581);
    connect(backBtn1,&MyPushButton::clicked,[=](){
        int n(0);
        for(int row=0;row<21;row++){
            for(int col=0;col<21;col++){
                if(!game->gameMapVec[row][col]==0) n++;
            }
        }
        if(n){
            game->gameMapVec[posrow_ex][poscol_ex]=0;
                game->gameMapVec[posrow][poscol]=0;
                posrow=0;
                poscol=0;
                posrow_ex=0;
                poscol_ex=0;
                update();
        }
    });
     initGame();
}
void rjdzwjs::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/26.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
    painter.setRenderHint(QPainter::Antialiasing,true);
    for(int i=0;i<22;i++){
        //从左到右竖线
        painter.drawLine(55+52*i,55,55+52*i,1146);
        //从上到下横线
        painter.drawLine(55,55+52*i,1146,55+52*i);
    }
    //绘制选中点
    QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        // 绘制落子标记(防止鼠标出框越界)
        if (clickPosRow > 0 && clickPosRow < 21 &&
            clickPosCol > 0 && clickPosCol < 21 &&
            game->gameMapVec[clickPosRow][clickPosCol] == 0)
        {
            if (game->playerFlag)
                brush.setColor(Qt::black);
            else
                brush.setColor(Qt::white);
            painter.setBrush(brush);
            painter.drawRect(55 + 52 * clickPosCol - 6 / 2, 55 + 52 * clickPosRow - 6 / 2, 6, 6);
        }
        //绘制棋子
        for(int i=1;i<21;i++){
            for(int j=1;j<21;j++){
                if(i==posrow_ex&&j==poscol_ex){
                    if(game->gameMapVec[posrow_ex][poscol_ex]==1){
                        brush.setColor(Qt::black);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                    else {
                        brush.setColor(Qt::white);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                }
                else if(game->gameMapVec[i][j]==1){
                    brush.setColor(Qt::black);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
                else if(game->gameMapVec[i][j]==-1){
                    brush.setColor(Qt::white);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
            }
        }
        if (clickPosRow > 0 && clickPosRow < 21 &&
                    clickPosCol > 0 && clickPosCol < 21 &&
               (game->gameMapVec[clickPosRow][clickPosCol] == 1 ||
                        game->gameMapVec[clickPosRow][clickPosCol] == -1))
           {
               if (game->winorlose(clickPosRow, clickPosCol) && game->gameStatus == PLAYING)
               {
                        // qDebug() << "win";
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QString str;
                   if (game->gameMapVec[clickPosRow][clickPosCol] == 1)
                       str = "玩家获胜";
                   else if (game->gameMapVec[clickPosRow][clickPosCol] == -1)
                       str = "电脑获胜";
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", str );
                   // 重置游戏状态，否则容易死循环
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                       posrow_ex=0;
                       poscol_ex=0;
                       posrow=0;
                       poscol=0;
                   }
               }
               else if (game->heqi())
                   {
                       QMessageBox::StandardButton btnValue = QMessageBox::information(this, "啊偶", "和棋了");
                       if (btnValue == QMessageBox::Ok)
                       {
                           game->startGame(game_type);
                           game->gameStatus = PLAYING;
                           posrow_ex=0;
                           poscol_ex=0;
                           posrow=0;
                           poscol=0;
                       }
                   }
           }
}
void rjdzwjs::initGame(){
    game = new GameModel;//初始化游戏模型
    initAIGame();
}
void rjdzwjs::initAIGame(){
    game_type=AIII;
    game->gameStatus=PLAYING;
    game->startGame(game_type);//在数据模型中进行初始化功能
    update();
}
void rjdzwjs::mouseMoveEvent(QMouseEvent *event)
{
    // 通过鼠标的hover确定落子的标记
    int x = event->x();
    int y = event->y();
    // 棋盘边缘不能落子
    if (x >= 55 +26&&
            x < 1121 &&
            y >= 55+26 &&
            y < 1121)
    {
        // 获取最近的左上角的点
        int col = (x-55) / 52;
        int row = (y-55) / 52;
        int leftTopPosX = 55 + 52 * col;
        int leftTopPosY = 55 + 52 * row;
        // 根据距离算出合适的点击位置,一共四个点，根据半径距离选最近的
        clickPosRow = -1; // 初始化最终的值
        clickPosCol = -1;
        int len = 0; // 计算完后取整就可以了
        selectPos =false;
        // 确定一个误差在范围内的点，且只可能确定一个出来
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
    }
    // 存了坐标后也要重绘
    update();
}
void rjdzwjs::mouseReleaseEvent(QMouseEvent *event){
    if(selectPos == false ){
        return ;
    }
    else{
        selectPos =false;
    }
    chessByPerson();
    if(game_type == AIII){
        QTimer::singleShot(1000, this, [=](){
            chessByAI();
        });
    }
}
void rjdzwjs::chessByPerson(){
    //根据当前存储的坐标落子
    //只有有效点击才下子，并且该处没有子
    if(clickPosRow !=-1&&clickPosCol!=-1&&game->gameMapVec[clickPosRow][clickPosCol]==0){
        QSound *luozi = new QSound(":/new/prefix1/res/123.wav",this);
        luozi->play();
        for(int row=1;row<21;row++){
            for(int col=1;col<21;col++){
                if( game->gameMapVec[row][col]==0){
                    game->gameMapVec[row][col]=3;         //不给点击其他位置
                }
            }
        }
        posrow= clickPosRow;
        poscol= clickPosCol;
        game->Person(clickPosRow,clickPosCol);

        //重绘
        update();
    }
}
void rjdzwjs::chessByAI()
{
    for(int row=1;row<21;row++){
        for(int col=1;col<21;col++){
            if( game->gameMapVec[row][col]==3){
                game->gameMapVec[row][col]=0;
            }
        }
    }
    game->AI(clickPosRow, clickPosCol);
    posrow_ex=clickPosRow;
    poscol_ex=clickPosCol;
   update();
}

jjdz.h中
#include"gamemodel.h"
#include <QMainWindow>
class jjdz : public QMainWindow
{
    Q_OBJECT
public:
    explicit jjdz(QWidget *parent = nullptr);
    //重新画背景图
    void paintEvent(QPaintEvent *);
    GameModel *game;//游戏指针
    GameType game_type;//存储游戏类型
    int clickPosRow,clickPosCol;    //存储将点击的位置
    bool selectPos = false;     //是否移动到合适的位置，以选中某个交叉点
    bool isWin;
    void initGame();                                     //游戏开始
    void initAIAIGame();                                 //AI开始
    void mouseMoveEvent(QMouseEvent *event);            //鼠标捕捉
    void mouseReleaseEvent(QMouseEvent *event);           //点击下棋
     void chessByAI2();                                      //电脑2下棋
         void chessByAI1();                          //电脑1下棋
signals:
    //自定义信号 点击返回
   void chooseSceneBack();
public slots:
};

jjdz.cpp中
#include<QMenuBar>
#include<QPainter>
#include"mypushbutton.h"
#include<QTimer>
#include"gamemodel.h"
#include<QMessageBox>
#include<QMouseEvent>
jjdz::jjdz(QWidget *parent) : QMainWindow(parent)
{
    setMouseTracking(true);
    //配置基本信息
   this->setFixedSize(1406,1200);
   //设置图标
   this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
   //设置标题
   this->setWindowTitle("机机对战");
    //创建菜单栏
    QMenuBar *bar5 = menuBar();
    setMenuBar(bar5);
    //创建开始菜单
    QMenu *startMenu = bar5->addMenu("帮助");
    //创建单项
    QAction * quitAction = startMenu->addAction("退出");
    //点击退出游戏
    connect(quitAction,&QAction::triggered,[=](){
        this->close();
    });
    //返回按钮
    MyPushButton *backBtn = new MyPushButton(":/new/prefix1/res/17.jpg",":/new/prefix1/res/18.jpg");
    backBtn->setParent(this);
    backBtn->move(1300,981);
    //点击返回
    connect(backBtn,&MyPushButton::clicked,[=](){
        if(QMessageBox::Yes == QMessageBox::question(this,"question","确定要退出吗？",QMessageBox::Yes|QMessageBox::No,QMessageBox::No)){
            for(int i=1;i<21;i++){
                for(int j=1;j<21;j++){
                    game->gameMapVec[i][j]=0;
                }
            }
            game->playerFlag=true;
            //延迟返回

            QTimer::singleShot(400,this,[=](){
                //返回主场景
                 emit this->chooseSceneBack();
            });
                }
    });
    initGame();
}
void jjdz::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/32.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
    painter.setRenderHint(QPainter::Antialiasing,true);
    for(int i=0;i<22;i++){
        //从左到右竖线
        painter.drawLine(55+52*i,55,55+52*i,1146);
        //从上到下横线
        painter.drawLine(55,55+52*i,1146,55+52*i);
    }
    //绘制选中点
    QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        // 绘制落子标记(防止鼠标出框越界)
        if (clickPosRow > 0 && clickPosRow < 21 &&
            clickPosCol > 0 && clickPosCol < 21 &&
            game->gameMapVec[clickPosRow][clickPosCol] == 0)
        {
            if (game->playerFlag)
                brush.setColor(Qt::black);
            else
                brush.setColor(Qt::white);
            painter.setBrush(brush);
            painter.drawRect(55 + 52 * clickPosCol - 6 / 2, 55 + 52 * clickPosRow - 6 / 2, 6, 6);
        }
        //绘制棋子
        for(int i=0;i<21;i++){
            for(int j=0;j<21;j++){
                if(game->gameMapVec[i][j]==1){
                    brush.setColor(Qt::black);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
                else if(game->gameMapVec[i][j]==-1){
                    brush.setColor(Qt::white);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
            }
        }
           if (game->jjwin() && game->gameStatus == PLAYING)
           {
                    // qDebug() << "win";
               game->gameStatus = WIN;
               QMessageBox::StandardButton btnValue = QMessageBox::information(this, "END", "游戏结束" );
               // 重置游戏状态，否则容易死循环
               if (btnValue == QMessageBox::Ok)
               {
                        game->startGame(game_type);
                   game->gameStatus = PLAYING;
               }
           }
           else if (game->heqi())
               {
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "啊偶", "和棋了");
                   if (btnValue == QMessageBox::Ok)
                   {
                       game->startGame(game_type);
                       game->gameStatus = PLAYING;
                   }
               }
}
void jjdz::initGame(){
    game = new GameModel;//初始化游戏模型
    initAIAIGame();
}
void jjdz::initAIAIGame(){
    game_type=AIAI;
    game->gameStatus=PLAYING;
    game->startGame(game_type);//在数据模型中进行初始化功能
    update();
}
void jjdz::mouseMoveEvent(QMouseEvent *event)
{
    // 通过鼠标的hover确定落子的标记
    int x = event->x();
    int y = event->y();
    // 棋盘边缘不能落子
    if (x >= 55 +26&&
            x < 1173 &&
            y >= 55+26 &&
            y < 1173)
    {
        // 获取最近的左上角的点
        int col = (x-55) / 52;
        int row = (y-55) / 52;
        int leftTopPosX = 55 + 52 * col;
        int leftTopPosY = 55 + 52 * row;
        // 根据距离算出合适的点击位置,一共四个点，根据半径距离选最近的
        clickPosRow = -1; // 初始化最终的值
        clickPosCol = -1;
        int len = 0; // 计算完后取整就可以了
        selectPos =false;
        // 确定一个误差在范围内的点，且只可能确定一个出来
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
    }
    // 存了坐标后也要重绘
    update();
}
void jjdz::mouseReleaseEvent(QMouseEvent *event){
    if(selectPos == false ){
        return ;
    }
    else{
        selectPos =false;
    }
    chessByAI1();
        QTimer::singleShot(1000, this, [=](){
            chessByAI2();
        });
}
void jjdz::chessByAI1(){
    game->AI1();
   update();
}
void jjdz::chessByAI2()
{
    game->AI2();
   update();
}