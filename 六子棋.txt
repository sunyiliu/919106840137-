GameModel.h中
#include<vector>
enum GameType
{
    PERSON,
   AIII,
    AIAI
};
// 游戏状态
enum GameStatus
{
    PLAYING,
    WIN,
    DEAD
};
class GameModel
{
public:
    GameModel(){};
public:
    std::vector<std::vector<int>> gameMapVec; // 存储当前游戏棋盘和棋子的情况,空白为0，白子1，黑子-1
    std::vector<std::vector<int>> scoreMapVec; // 存储各个点位的评分情况，作为AI下棋依据
    std::vector<std::vector<int>> scoreMapVec1; // 存储各个点位的评分情况，作为AI下棋依据
    bool playerFlag; // 标示下棋方
    GameType gameType; // 游戏模式
    GameStatus gameStatus; // 游戏状态
    void startGame(GameType type); // 开始游戏
    void Person(int row, int col);    //人下棋
    void AI(int &clickRow, int &clickCol);   //电脑下棋
    void updataGameMap(int row,int col);     //更新棋盘
    bool winorlose(int row, int col);       //判断输赢
    bool heqi();                             //判断和棋
    bool nohands(int row, int col);         //判断禁手
    void computer();                     //电脑落子判断
    void AI1();                            //电脑1判断
    void AI2();                             //电脑2判断
    void computer1();                      //电脑落子2判断
    bool jjwin();                           //电脑和电脑输赢判断
};

GameModel.cpp中
#include"gamemodel.h"
#include<stdlib.h>
#include<stdio.h>
#include<time.h>
void GameModel::startGame(GameType type){
    gameType = type;
       // 初始棋盘
       gameMapVec.clear();
       for (int i = 0; i < 22; i++)
       {
           std::vector<int> lineBoard;
           for (int j = 0; j < 22; j++)
                 lineBoard.push_back(0);
           gameMapVec.push_back(lineBoard);
}
       // 如果是AI模式，初始化评分数组
          if (gameType == AIII)
          {
                    scoreMapVec.clear();
              for (int i = 0; i < 22; i++)
              {
                 std::vector<int> lineScores;
                  for (int j = 0; j < 22;j++);
                  lineScores.push_back(0);
                  scoreMapVec.push_back(lineScores);
              }
          }
          //AIAI模式，初始化两个评分数组
          else if(gameType == AIAI){
              scoreMapVec.clear();
              scoreMapVec1.clear();
              for (int i = 0; i < 22; i++)
              {
                  std::vector<int> lineScores;
                  for (int j = 0; j < 22;j++);
                  lineScores.push_back(0);
                  scoreMapVec.push_back(lineScores);
                  scoreMapVec1.push_back(lineScores);
        }
          }
          // 己方下为true,对方下位false
          playerFlag = true;
}
void GameModel::Person(int row,int col){
    updataGameMap(row,col);
}
void GameModel::AI(int &clickRow, int &clickCol)
{
    // 计算评分
    computer();
    // 从评分中找出最大分数的位置
    int maxScore = 0;
    std::vector<std::pair<int, int>> maxPoints;
    for (int row = 1; row < 21; row++)
        for (int col = 1; col < 21; col++)
        {
            // 前提是这个坐标是空的
            if (gameMapVec[row][col] == 0)
            {
                if (scoreMapVec[row][col] > maxScore)          // 找最大的数和坐标
                {
                    maxPoints.clear();
                    maxScore = scoreMapVec[row][col];
                    maxPoints.push_back(std::make_pair(row, col));
                }
                else if (scoreMapVec[row][col] == maxScore)     // 如果有多个最大的数，都存起来
                    maxPoints.push_back(std::make_pair(row, col));
            }
        }
    // 随机落子，如果有多个点的话
    srand((unsigned)time(0));
    int index = rand() % maxPoints.size();
    std::pair<int, int> pointPair = maxPoints.at(index);
    clickRow = pointPair.first; // 记录落子点
    clickCol = pointPair.second;
    updataGameMap(clickRow, clickCol);
}
void GameModel::updataGameMap(int row,int col){
    if(playerFlag)
        gameMapVec[row][col]=1;
    else
        gameMapVec[row][col]=-1;
    //换手
    playerFlag= !playerFlag;
}
bool GameModel::winorlose(int row, int col)        //简单判断输赢（六子连起来）
{

    int count = 0;                                //六子为赢，循环六次
    int winflag = 1;                              //记录连续几颗棋子相连
    int i, j;
    for (i = row - 1, j = col ; i > 0 && count++ < 6; i--)    //竖向判断
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    for (i = row+1 , j = col; i < 21 && count++ < 6; i++)
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    if (winflag >= 6)
        return true;
    else
        winflag = 1;
    for (i = row, j = col+1 ; j < 21 && count++ < 6; j++)     //横向判断
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    for (i = row, j = col - 1; j > 0 && count++ < 6; j--)
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    if (winflag >= 6)
        return true;
    else
        winflag = 1;
    for (i = row+1 , j = col+1 ; i < 21 && j < 21 && count++ < 6; i++, j++)   //左斜方向判断
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    for (i = row - 1, j = col - 1; i > 0 && j > 0 && count++ < 6; i--, j--)
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    if (winflag >= 6)
        return true;
    else
        winflag = 1;
    for (i = row - 1, j = col+1 ; i > 0 && j < 21 && count++ < 6; i--, j++)   //右斜方向判断
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    for (i = row+1 , j = col - 1; i < 21 && j > 0 && count++ < 6; i++, j--)
    {
        if (gameMapVec[i][j] == gameMapVec[row][col])
            winflag++;
        else
            break;
    }
    count = 0;
    if (winflag >= 6)
        return true;
    else
        winflag = 1;
    return false;
}
bool GameModel::heqi()
{
    // 所有空格全部填满
    for (int i = 1; i < 21; i++)
        for (int j = 1; j < 21; j++)
        {
            if (!(gameMapVec[i][j] == 1 || gameMapVec[i][j] == -1))
                return false;
        }
    return true;
}
bool GameModel::nohands(int row,int col){
    int count = 0;                                     //禁手最少四子相连，循环四次
        int num(0);
        int numm(0);//记录几个方向出现四子及以上相连
        int winflag = 1;                                   //记录连续棋子相连个数
        int i, j;
        int cur;
        cur=1;
        for (i = row-1, j = col; i > 0 && count++ < 5; i--)   //竖向判断
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        for (i = row+1, j = col; i < 21 && count++ < 5; i++)
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        if (winflag == 4 ) {
            num++;                                    //出现则次数加一
            winflag = 1;
        }
        else if(winflag==5){
            numm++;
            winflag=1;
        }
        else
            winflag = 1;
        for (i = row, j = col+1; j < 21 && count++ < 5; j++)    //横向判断
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        for (i = row, j = col-1; j > 0 && count++ < 5; j--)
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        if (winflag ==4) {
            num++;
            winflag = 1;
        }
        else if(winflag==5){
            numm++;
            winflag=1;
        }
        else
            winflag = 1;
        for (i = row+1, j = col+1; i < 21 && j < 21 && count++ < 5; i++, j++)
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        for (i = row-1, j = col-1; i > 0 && j > 0 && count++ < 5; i--, j--)  //左斜判断
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        if (winflag ==4) {
            num++;
            winflag = 1;
        }
        else if(winflag==5) {
            numm++;
            winflag=1;
        }
        else
            winflag = 1;
        for (i = row-1, j = col+1; i > 0 && j < 21 && count++ < 5; i--, j++)   //右斜判断
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        for (i = row+1, j = col-1; i < 21 && j > 0 && count++ < 5; i++, j--)
        {
            if (gameMapVec[i][j] == cur)
                winflag++;
            else
                break;
        }
        count = 0;
        if (winflag ==4) {
            num++;
            winflag = 1;
        }
        else if(winflag==5){
            numm++;
            winflag=1;
        }
        else
            winflag = 1;
        if (num >= 2||numm>=2) return true;      //出现最少两个方向禁手，则返回白子胜利
        else return false;
}
void GameModel::computer(){
       int personNum = 0; // 玩家连成子的个数
       int botNum = 0; // AI连成子的个数
       int emptyNum = 0; // 各方向空白位的个数
       // 清空评分
       scoreMapVec.clear();
       for (int i = 0; i < 21; i++)
       {
           std::vector<int> lineScores;
           for (int j = 0; j <= 21; j++)
               lineScores.push_back(0);
           scoreMapVec.push_back(lineScores);
       }
       //积分机制
       //玩家
       //两颗 4  死三 20  活三 30  死四 45  活四  95  五颗 8000
       //电脑
       //一颗 1  两颗 5  死三 15  活三 40  死四 50  活四 90  五颗 10000
       // 计分（此处是完全遍历）
       for (int row = 1; row < 21; row++)
           for (int col = 1; col < 21;col++)
           {
               // 空白点就算
               if (row > 0 && col > 0 &&
                   gameMapVec[row][col] == 0)
               {
                   // 遍历周围八个方向
                   for (int y = -1; y <= 1; y++)
                       for (int x = -1; x <= 1; x++)
                       {
                           // 重置
                           personNum = 0;
                           botNum = 0;
                           emptyNum = 0;
                           // 原坐标不算
                           if (y != 0 || x != 0)
                           {
                               // 每个方向延伸5个子
                               // 对玩家白子评分（正反两个方向）
                               for (int i = 1; i <= 5; i++)
                               {
                                   if (row + i * y > 0 && row + i * y < 21&&
                                       col + i * x > 0 && col + i * x < 21 &&
                                       gameMapVec[row + i * y][col + i * x] == 1) // 玩家的子
                                   {
                                       personNum++;
                                   }
                                   else if (row + i * y > 0 && row + i * y <21 &&
                                            col + i * x > 0 && col + i * x < 21 &&
                                            gameMapVec[row + i * y][col + i * x] == 0) // 空白位
                                   {
                                       emptyNum++;
                                       break;
                                   }
                                   else            // 出边界
                                       break;
                               }
                               for (int i = 1; i <= 5; i++)
                               {
                                   if (row - i * y > 0 && row - i * y < 21 &&
                                       col - i * x > 0 && col - i * x < 21&&
                                       gameMapVec[row - i * y][col - i * x] == 1) // 玩家的子
                                   {
                                       personNum++;
                                   }
                                   else if (row - i * y > 0 && row - i * y < 21 &&
                                            col - i * x > 0 && col - i * x < 21 &&
                                            gameMapVec[row - i * y][col - i * x] == 0) // 空白位
                                   {
                                       emptyNum++;
                                       break;
                                   }
                                   else            // 出边界
                                       break;
                               }
                               if (personNum == 2)                      // 杀三
                                   scoreMapVec[row][col] += 4;
                               else if (personNum == 3)                // 杀四
                               {
                                   if (emptyNum == 1)
                                       scoreMapVec[row][col] += 20;
                                   else if (emptyNum == 2)
                                       scoreMapVec[row][col] += 30;
                               }
                               else if (personNum == 4)                 // 杀五
                               {
                                   // 量变空位不一样，优先级不一样
                                   if (emptyNum == 1)
                                       scoreMapVec[row][col] += 45;
                                   else if (emptyNum == 2)
                                       scoreMapVec[row][col] += 95;
                               }
                               else if (personNum == 5)                 // 杀六
                                   scoreMapVec[row][col] += 8000;
                               // 进行一次清空
                               emptyNum = 0;
                               // 对AI黑子评分
                               for (int i = 1; i <= 5; i++)
                               {
                                   if (row + i * y > 0 && row + i * y < 21 &&
                                       col + i * x > 0 && col + i * x < 21 &&
                                       gameMapVec[row + i * y][col + i * x] == 1) // 玩家的子
                                   {
                                       botNum++;
                                   }
                                   else if (row + i * y > 0 && row + i * y <21 &&
                                            col + i * x > 0 && col + i * x < 21 &&
                                            gameMapVec[row +i * y][col + i * x] == 0) // 空白位
                                   {
                                       emptyNum++;
                                       break;
                                   }
                                   else            // 出边界
                                       break;
                               }
                               for (int i = 1; i <= 5; i++)
                               {
                                   if (row - i * y > 0 && row - i * y < 21 &&
                                       col - i * x > 0 && col - i * x < 21 &&
                                       gameMapVec[row - i * y][col - i * x] == -1) // AI的子
                                   {
                                       botNum++;
                                   }
                                   else if (row - i * y > 0 && row - i * y < 21 &&
                                            col - i * x > 0 && col - i * x < 21&&
                                            gameMapVec[row - i * y][col - i * x] == 0) // 空白位
                                   {
                                       emptyNum++;
                                       break;
                                   }
                                   else            // 出边界
                                       break;
                               }
                               if (botNum == 1)                      // 普通下子
                                   scoreMapVec[row][col] += 1;
                               else if (botNum == 2)                 // 二
                                   scoreMapVec[row][col] += 5;
                               else if (botNum == 3)
                               {
                                   if (emptyNum == 1)                // 死三
                                       scoreMapVec[row][col] += 15;
                                   else if (emptyNum == 2)
                                       scoreMapVec[row][col] += 40;  // 活三
                               }
                               else if (botNum == 4)
                               {
                                   if (emptyNum == 1)                // 死四
                                       scoreMapVec[row][col] += 50;
                                   else if (emptyNum == 2)
                                       scoreMapVec[row][col] += 90; // 活四
                               }
                               else if (botNum >= 5)
                                   scoreMapVec[row][col] += 10000;   // 活五
                           }
                       }
               }
           }
}

MainScene.h中
#include <QMainWindow>
#include<wjdzyjs.h>
#include<wjdzwjs.h>
#include<rjdzyjs.h>
#include<rjdzwjs.h>
#include<jjdz.h>
namespace Ui {
class MainScene;
}
class MainScene : public QMainWindow
{
    Q_OBJECT
public:
    explicit MainScene(QWidget *parent = 0);
    ~MainScene();
    //重新画背景图
    void paintEvent(QPaintEvent *);
    wjdzyjs *window1 = NULL;
    wjdzwjs *window2 = NULL;
    rjdzyjs *window3 = NULL;
    rjdzwjs *window4 = NULL;
    jjdz *window5 = NULL;
private:
    Ui::MainScene *ui;
};

MainScene.cpp中
#include "mainscene.h"
#include "ui_mainscene.h"
#include<QPainter>
#include<QDialog>
#include<QDebug>
#include<mypushbutton.h>
#include<QTimer>
MainScene::MainScene(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainScene)
{
    ui->setupUi(this);
    //设置固定大小
    this->setFixedSize(916,1293);
    //设置图标
    this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
    //设置标题
    this->setWindowTitle("快乐六子棋");
    //退出按钮
    connect(ui->actionfail,&QAction::triggered,[=](){
        this->close();
    });
    //开始按钮
    MyPushButton *startBtn1 = new MyPushButton(":/new/prefix1/res/9.png");
    startBtn1->setParent(this);
    startBtn1->move(60,650);
    MyPushButton *startBtn2 = new MyPushButton(":/new/prefix1/res/10.png");
    startBtn2->setParent(this);
    startBtn2->move(100,750);
    MyPushButton *startBtn3 = new MyPushButton(":/new/prefix1/res/11.png");
    startBtn3->setParent(this);
    startBtn3->move(140,850);
    MyPushButton *startBtn4 = new MyPushButton(":/new/prefix1/res/12.png");
    startBtn4->setParent(this);
    startBtn4->move(180,950);
    MyPushButton *startBtn5 = new MyPushButton(":/new/prefix1/res/34.png");
    startBtn5->setParent(this);
    startBtn5->move(420,1100);
    //实例化场景
    window1 = new wjdzyjs;
    window2 = new wjdzwjs;
    window3 = new rjdzyjs;
    window4 = new rjdzwjs;
    window5 = new jjdz;
    //监听选择按钮信号
    connect(window1,&wjdzyjs::chooseSceneBack,this,[=](){
        this->setGeometry(window1->geometry());
        window1->hide();  //场景隐藏
        this->show();   //主页出现
    });
    //监听选择按钮信号
    connect(window2,&wjdzwjs::chooseSceneBack,this,[=](){
        this->setGeometry(window2->geometry());
        window2->hide();  //场景隐藏
        this->show();   //主页出现
    });
    //监听选择按钮信号
    connect(window3,&rjdzyjs::chooseSceneBack,this,[=](){
        this->setGeometry(window3->geometry());
        window3->hide();  //场景隐藏
        this->show();   //主页出现
    });
    //监听选择按钮信号
    connect(window4,&rjdzwjs::chooseSceneBack,this,[=](){
        this->setGeometry(window4->geometry());
        window4->hide();  //场景隐藏
        this->show();   //主页出现
    });
    //监听选择按钮信号
    connect(window5,&jjdz::chooseSceneBack,this,[=](){
        this->setGeometry(window5->geometry());
        window5->hide();  //场景隐藏
        this->show();   //主页出现
    });
    connect(startBtn1,&MyPushButton::clicked,[=](){
        //弹起特效
        startBtn1->jump1();
        startBtn1->jump2();
        //延时进入
        QTimer::singleShot(400,this,[=](){
            //设置window的位置
            window1->setGeometry(this->geometry());
            //进入wjdzyjs窗口
            //自身隐藏
           this->hide();
            //显示场景
           window1->show();
        });
    });
    connect(startBtn2,&MyPushButton::clicked,[=](){
        startBtn2->jump1();
        startBtn2->jump2();
        QTimer::singleShot(400,this,[=](){
            //设置window的位置
            window2->setGeometry(this->geometry());
            this->hide();
            //显示场景
            window2->show();
        });
    });
    connect(startBtn3,&MyPushButton::clicked,[=](){
        startBtn3->jump1();
        startBtn3->jump2();
        QTimer::singleShot(400,this,[=](){
            //设置window的位置
            window3->setGeometry(this->geometry());
            this->hide();
            //显示场景
            window3->show();
        });
    });
    connect(startBtn4,&MyPushButton::clicked,[=](){
        startBtn4->jump1();
        startBtn4->jump2();
        QTimer::singleShot(400,this,[=](){
            //设置window的位置
            window4->setGeometry(this->geometry());
            this->hide();
            //显示场景
            window4->show();
        });
    });
    connect(startBtn5,&MyPushButton::clicked,[=](){
        startBtn5->jump1();
        startBtn5->jump2();
        QTimer::singleShot(400,this,[=](){
            //设置window的位置
            window5->setGeometry(this->geometry());
            this->hide();
            //显示场景
            window5->show();
        });
    });
}
void MainScene::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/4.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
}

MyPushButton.h中
class MyPushButton : public QPushButton
{
    Q_OBJECT
public:
    //构造函数 参数1 正常显示  参数2 按下后显示
    MyPushButton(QString normalImg,QString pressImg = "");
    //成员函数 保存用户传入的默认路径以及按下后显示的图片路径
    QString normalImgPath;
    QString pressImgPath;
    //弹起
    void jump1();  //向下
    void jump2();  //向上
    //重写按钮按下和释放
    void mousePressEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);
signals:
public slots:
};

MyPushButton.cpp中
#include "mypushbutton.h"
#include<QDebug>
#include<QPropertyAnimation>
MyPushButton::MyPushButton(QString normalImg, QString pressImg ){
    this->normalImgPath = normalImg;
    this->pressImgPath = pressImg;
    QPixmap pix;
    bool ret = pix.load(normalImg);
    if(!ret){
        qDebug()<<"图片加载失败";
        return ;
    }
    //设置图片固定大小
    this->setFixedSize(pix.width(),pix.height());
    //设置图标
    this->setIcon(pix);
    //设置图标大小
    this->setIconSize(QSize(pix.width(),pix.height()));
}
void MyPushButton::jump1(){
    //创建动画对象
    QPropertyAnimation *animation = new QPropertyAnimation(this,"geometry");
    //设置动画时间间隔
    animation->setDuration(400);
    //起始位置
    animation->setStartValue(QRect(this->x(),this->y(),this->width(),this->height()));
    //结束位置
     animation->setEndValue(QRect(this->x(),this->y()+10,this->width(),this->height()));
     //设置曲线
     animation->setEasingCurve(QEasingCurve::OutBounce);
     //执行动画
     animation->start();
}
void MyPushButton::jump2(){
    //创建动画对象
    QPropertyAnimation *animation = new QPropertyAnimation(this,"geometry");
    //设置动画时间间隔
    animation->setDuration(400);
    //起始位置
    animation->setStartValue(QRect(this->x(),this->y()+10,this->width(),this->height()));
    //结束位置
     animation->setEndValue(QRect(this->x(),this->y(),this->width(),this->height()));
     //设置曲线
     animation->setEasingCurve(QEasingCurve::OutBounce);
     //执行动画
     animation->start();
}
void MyPushButton::mousePressEvent(QMouseEvent *e){
    if(this->pressImgPath!=""){    //传入的按下图片不为空，说明需要按下状态，切换图片
        QPixmap pix;
        bool ret = pix.load(this->pressImgPath);
        if(!ret){
            qDebug()<<"图片加载失败";
            return ;
        }
        //设置图片固定大小
        this->setFixedSize(pix.width(),pix.height());
        //设置图标
        this->setIcon(pix);
        //设置图标大小
        this->setIconSize(QSize(pix.width(),pix.height()));
    }
    //让父类执行其他内容
    return QPushButton::mousePressEvent(e);
}
void MyPushButton::mouseReleaseEvent(QMouseEvent *e){
    if(this->pressImgPath!=""){    //传入的按下图片不为空，说明需要按下状态，切换成原图片
        QPixmap pix;
        bool ret = pix.load(this->normalImgPath);
        if(!ret){
            qDebug()<<"图片加载失败";
            return ;
        }
        //设置图片固定大小
        this->setFixedSize(pix.width(),pix.height());
        //设置图标
        this->setIcon(pix);
        //设置图标大小
        this->setIconSize(QSize(pix.width(),pix.height()));
    }
    //让父类执行其他内容
    return QPushButton::mouseReleaseEvent(e);
}

wjdzyjs.h中
#include"gamemodel.h"
#include <QMainWindow>
class wjdzyjs : public QMainWindow
{
    Q_OBJECT
public:
    explicit wjdzyjs(QWidget *parent = nullptr);
    //重新画背景图
    void paintEvent(QPaintEvent *);
    GameModel *game;//游戏指针
    GameType game_type;//存储游戏类型
    int clickPosRow,clickPosCol;    //存储将点击的位置
    int posrow,poscol;                //上一步棋子
    bool selectPos = false;     //是否移动到合适的位置，以选中某个交叉点
    bool isWin;
    void initGame();
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void chessOneByPerson();
     void initPVPGame();
signals:
    //自定义信号 点击返回
   void chooseSceneBack();
public slots:
};

wjdzyjs.cpp中
#include "wjdzyjs.h"
#include<QMenuBar>
#include<QPainter>
#include"mypushbutton.h"
#include<QTimer>
#include<QMouseEvent>
#include<math.h>
#include"gamemodel.h"
#include<QDebug>
#include<QMessageBox>
wjdzyjs::wjdzyjs(QWidget *parent) : QMainWindow(parent)
{
   setMouseTracking(true);
   //配置基本信息
  this->setFixedSize(1406,1200);
    //设置图标
    this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
    //设置标题
    this->setWindowTitle("玩家对战（有禁手）");
     //创建菜单栏
     QMenuBar *bar1 = menuBar();
     setMenuBar(bar1);
     //创建开始菜单
     QMenu *startMenu = bar1->addMenu("帮助");
     //创建单项
     QAction * quitAction = startMenu->addAction("退出");
     //点击退出游戏
     connect(quitAction,&QAction::triggered,[=](){
         this->close();
     });
    //返回按钮
    MyPushButton *backBtn = new MyPushButton(":/new/prefix1/res/17.jpg",":/new/prefix1/res/18.jpg");
    backBtn->setParent(this);
    backBtn->move(1300,981);
    //点击返回
    connect(backBtn,&MyPushButton::clicked,[=](){
        for(int i=1;i<21;i++){
            for(int j=1;j<21;j++){
                game->gameMapVec[i][j]=0;
            }
        }
        game->playerFlag=true;
        //延迟返回
        QTimer::singleShot(400,this,[=](){
            //返回主场景
             emit this->chooseSceneBack();
        });
    });
    MyPushButton *backBtn1 = new MyPushButton(":/new/prefix1/res/40.jpg",":/new/prefix1/res/41.jpg");
    backBtn1->setParent(this);
    backBtn1->move(1280,581);
    connect(backBtn1,&MyPushButton::clicked,[=](){
        int n(0);
        for(int row=0;row<21;row++){
            for(int col=0;col<21;col++){
                if(!game->gameMapVec[row][col]==0) n++;
            }
        }
        if(n){
            game->playerFlag=!game->playerFlag;
                game->gameMapVec[posrow][poscol]=0;
                update();
        }
    });
     initGame();
}
void wjdzyjs::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/23.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
    painter.setRenderHint(QPainter::Antialiasing,true);
    for(int i=0;i<22;i++){
        //从左到右竖线
        painter.drawLine(55+52*i,55,55+52*i,1146);
        //从上到下横线
        painter.drawLine(55,55+52*i,1146,55+52*i);
    }
    //绘制选中点
    QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        // 绘制落子标记(防止鼠标出框越界)
        if (clickPosRow > 0 && clickPosRow < 21 &&
            clickPosCol > 0 && clickPosCol < 21 &&
            game->gameMapVec[clickPosRow][clickPosCol] == 0)
        {
            if (game->playerFlag)
                brush.setColor(Qt::black);
            else
                brush.setColor(Qt::white);
            painter.setBrush(brush);
            painter.drawRect(55 + 52 * clickPosCol - 6 / 2, 55 + 52 * clickPosRow - 6 / 2, 6, 6);
        }
        //绘制棋子
        for(int i=0;i<21;i++){
            for(int j=0;j<21;j++){
                if(game->gameMapVec[i][j]==1){
                    brush.setColor(Qt::black);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
                else if(game->gameMapVec[i][j]==-1){
                    brush.setColor(Qt::white);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
            }
        }
        if (clickPosRow > 0 && clickPosRow < 21 &&
                    clickPosCol > 0 && clickPosCol < 21 &&
               (game->gameMapVec[clickPosRow][clickPosCol] == 1 ||
                        game->gameMapVec[clickPosRow][clickPosCol] == -1))
           {
               if (game->winorlose(clickPosRow, clickPosCol) && game->gameStatus == PLAYING)
               {
                        // qDebug() << "win";
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QString str;
                   if (game->gameMapVec[clickPosRow][clickPosCol] == 1)
                       str = "黑棋获胜";
                   else if (game->gameMapVec[clickPosRow][clickPosCol] == -1)
                       str = "白棋获胜";
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", str );
                   // 重置游戏状态，否则容易死循环
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                   }
               }
               else if (game->heqi())
                   {
                       QMessageBox::StandardButton btnValue = QMessageBox::information(this, "啊偶", "和棋了");
                       if (btnValue == QMessageBox::Ok)
                       {
                           game->startGame(game_type);
                           game->gameStatus = PLAYING;
                       }
                   }
               else if (game->gameMapVec[clickPosRow][clickPosCol]==1&& game->nohands(clickPosRow,clickPosCol)){
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", "白棋获胜" );
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                   }
               }
           }
}
void wjdzyjs::initGame(){
    game = new GameModel;//初始化游戏模型
    initPVPGame();
}
void wjdzyjs::initPVPGame()
{
    game_type = PERSON;
    game->gameStatus = PLAYING;
    game->startGame(game_type);
    update();
}
void wjdzyjs::mouseMoveEvent(QMouseEvent *event)
{
    // 通过鼠标的hover确定落子的标记
    int x = event->x();
    int y = event->y();
    // 棋盘边缘不能落子
    if (x >= 55 +26&&
            x < 1173 &&
            y >= 55+26 &&
            y < 1173)
    {
        // 获取最近的左上角的点
        int col = (x-55) / 52;
        int row = (y-55) / 52;
        int leftTopPosX = 55 + 52 * col;
        int leftTopPosY = 55 + 52 * row;
        // 根据距离算出合适的点击位置,一共四个点，根据半径距离选最近的
        clickPosRow = -1; // 初始化最终的值
        clickPosCol = -1;
        int len = 0; // 计算完后取整就可以了
        selectPos =false;
        // 确定一个误差在范围内的点，且只可能确定一个出来
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
    }
    // 存了坐标后也要重绘
    update();
}
void wjdzyjs::mouseReleaseEvent(QMouseEvent *event){
    if(selectPos == false ){
        return ;
    }
    else{
        selectPos =false;
    }
    chessOneByPerson();
}
void wjdzyjs::chessOneByPerson(){
    //根据当前存储的坐标落子
    //只有有效点击才下子，并且该处没有子
    if(clickPosRow !=-1&&clickPosCol!=-1&&game->gameMapVec[clickPosRow][clickPosCol]==0){
        posrow= clickPosRow;
        poscol= clickPosCol;
        game->Person(clickPosRow,clickPosCol);
        //重绘
        update();
    }
}

wjdzwjs.h中
#include"gamemodel.h"
#include <QMainWindow>
class wjdzwjs : public QMainWindow
{
    Q_OBJECT
public:
    explicit wjdzwjs(QWidget *parent = nullptr);
    //重新画背景图
    void paintEvent(QPaintEvent *);
    GameModel *game;//游戏指针
    GameType game_type;//存储游戏类型
    int clickPosRow,clickPosCol;    //存储将点击的位置
    bool selectPos = false;     //是否移动到合适的位置，以选中某个交叉点
    bool isWin;
    int posrow,poscol;
    void initGame();
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void chessOneByPerson();
     void initPVPGame();
signals:
    //自定义信号 点击返回
   void chooseSceneBack();
public slots:
};

wjdzwjs.cpp中
#include "wjdzwjs.h"
#include<QMenuBar>
#include<QPainter>
#include"mypushbutton.h"
#include<QTimer>
#include<QMouseEvent>
#include<math.h>
#include"gamemodel.h"
#include<QDebug>
#include<QMessageBox>
wjdzwjs::wjdzwjs(QWidget *parent) : QMainWindow(parent)
{
     setMouseTracking(true);
    //配置基本信息
   this->setFixedSize(1406,1200);
   //设置图标
   this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
   //设置标题
   this->setWindowTitle("玩家对战（无禁手）");
    //创建菜单栏
    QMenuBar *bar2 = menuBar();
    setMenuBar(bar2);
    //创建开始菜单
    QMenu *startMenu = bar2->addMenu("帮助");
    //创建单项
    QAction * quitAction = startMenu->addAction("退出");
    //点击退出游戏
    connect(quitAction,&QAction::triggered,[=](){
        this->close();
    });
    //返回按钮
    MyPushButton *backBtn = new MyPushButton(":/new/prefix1/res/17.jpg",":/new/prefix1/res/18.jpg");
    backBtn->setParent(this);
    backBtn->move(1300,981);
    //点击返回
    connect(backBtn,&MyPushButton::clicked,[=](){
        for(int i=1;i<21;i++){
            for(int j=1;j<21;j++){
                game->gameMapVec[i][j]=0;            }
        }
        game->playerFlag=true;
        //延迟返回
        QTimer::singleShot(400,this,[=](){
            //返回主场景
             emit this->chooseSceneBack();
        });
    });
    MyPushButton *backBtn1 = new MyPushButton(":/new/prefix1/res/40.jpg",":/new/prefix1/res/41.jpg");
    backBtn1->setParent(this);
    backBtn1->move(1280,581);
    connect(backBtn1,&MyPushButton::clicked,[=](){
        int n(0);
        for(int row=0;row<21;row++){
            for(int col=0;col<21;col++){
                if(!game->gameMapVec[row][col]==0) n++;
            }
        }
        if(n){
            game->playerFlag=!game->playerFlag;
                game->gameMapVec[posrow][poscol]=0;
                update();
        }
    });
     initGame();
}
void wjdzwjs::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/24.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
    painter.setRenderHint(QPainter::Antialiasing,true);
    for(int i=0;i<22;i++){
        //从左到右竖线
        painter.drawLine(55+52*i,55,55+52*i,1146);
        //从上到下横线
        painter.drawLine(55,55+52*i,1146,55+52*i);
    }
    //绘制选中点
    QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        // 绘制落子标记(防止鼠标出框越界)
        if (clickPosRow > 0 && clickPosRow < 21 &&
            clickPosCol > 0 && clickPosCol < 21 &&
            game->gameMapVec[clickPosRow][clickPosCol] == 0)
        {
            if (game->playerFlag)
                brush.setColor(Qt::black);
            else
                brush.setColor(Qt::white);
            painter.setBrush(brush);
            painter.drawRect(55 + 52 * clickPosCol - 6 / 2, 55 + 52 * clickPosRow - 6 / 2, 6, 6);
        }
        //绘制棋子
        for(int i=0;i<21;i++){
            for(int j=0;j<21;j++){
                if(game->gameMapVec[i][j]==1){
                    brush.setColor(Qt::black);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
                else if(game->gameMapVec[i][j]==-1){
                    brush.setColor(Qt::white);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
            }
        }
        if (clickPosRow > 0 && clickPosRow < 21 &&
                    clickPosCol > 0 && clickPosCol < 21 &&
               (game->gameMapVec[clickPosRow][clickPosCol] == 1 ||
                        game->gameMapVec[clickPosRow][clickPosCol] == -1))
           {
               if (game->winorlose(clickPosRow, clickPosCol) && game->gameStatus == PLAYING)
               {
                        // qDebug() << "win";
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QString str;
                   if (game->gameMapVec[clickPosRow][clickPosCol] == 1)
                       str = "黑棋获胜";
                   else if (game->gameMapVec[clickPosRow][clickPosCol] == -1)
                       str = "白棋获胜";
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", str );
                   // 重置游戏状态，否则容易死循环
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                   }
               }
               else if (game->heqi())
                   {
                       QMessageBox::StandardButton btnValue = QMessageBox::information(this, "啊偶", "和棋了");
                       if (btnValue == QMessageBox::Ok)
                       {
                           game->startGame(game_type);
                           game->gameStatus = PLAYING;
                       }
                   }
           }
}
void wjdzwjs::initGame(){
    game = new GameModel;//初始化游戏模型
    initPVPGame();
}
void wjdzwjs::initPVPGame()
{
    game_type = PERSON;
    game->gameStatus = PLAYING;
    game->startGame(game_type);
    update();
}
void wjdzwjs::mouseMoveEvent(QMouseEvent *event)
{
    // 通过鼠标的hover确定落子的标记
    int x = event->x();
    int y = event->y();
    // 棋盘边缘不能落子
    if (x >= 55 +26&&
            x < 1173 &&
            y >= 55+26 &&
            y < 1173)
    {
        // 获取最近的左上角的点
        int col = (x-55) / 52;
        int row = (y-55) / 52;
        int leftTopPosX = 55 + 52 * col;
        int leftTopPosY = 55 + 52 * row;
        // 根据距离算出合适的点击位置,一共四个点，根据半径距离选最近的
        clickPosRow = -1; // 初始化最终的值
        clickPosCol = -1;
        int len = 0; // 计算完后取整就可以了
        selectPos =false;
        // 确定一个误差在范围内的点，且只可能确定一个出来
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
    }
    // 存了坐标后也要重绘
    update();
}
void wjdzwjs::mouseReleaseEvent(QMouseEvent *event){
    if(selectPos == false ){
        return ;
    }
    else{
        selectPos =false;
    }
    chessOneByPerson();
}
void wjdzwjs::chessOneByPerson(){
    //根据当前存储的坐标落子
    //只有有效点击才下子，并且该处没有子
    if(clickPosRow !=-1&&clickPosCol!=-1&&game->gameMapVec[clickPosRow][clickPosCol]==0){
        posrow= clickPosRow;
        poscol= clickPosCol;
        game->Person(clickPosRow,clickPosCol);
        //重绘
        update();
    }
}

rjdzyjs.h中
#include"gamemodel.h"
#include <QMainWindow>
class rjdzyjs : public QMainWindow
{
    Q_OBJECT
public:
    explicit rjdzyjs(QWidget *parent = nullptr);
    //重新画背景图
    void paintEvent(QPaintEvent *);
    GameModel *game;//游戏指针
    GameType game_type;//存储游戏类型
    int clickPosRow,clickPosCol;    //存储将点击的位置
    bool selectPos = false;     //是否移动到合适的位置，以选中某个交叉点
    bool isWin ;
    int posrow,poscol;
    int posrow_ex,poscol_ex;
    void initGame();
    void initAIGame();
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void chessByPerson();
     void chessByAI();
signals:
    //自定义信号 点击返回
   void chooseSceneBack();
public slots:
};

rjdzyjs.cpp中
#include "rjdzyjs.h"
#include<QMenuBar>
#include<QPainter>
#include"mypushbutton.h"
#include<QTimer>
#include<QMouseEvent>
#include<math.h>
#include"gamemodel.h"
#include<QDebug>
#include<QMessageBox>
rjdzyjs::rjdzyjs(QWidget *parent) : QMainWindow(parent)
{
     setMouseTracking(true);
    //配置基本信息
   this->setFixedSize(1406,1200);
   //设置图标
   this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
   //设置标题
   this->setWindowTitle("人机对战（有禁手）");
    //创建菜单栏
    QMenuBar *bar3 = menuBar();
    setMenuBar(bar3);
    //创建开始菜单
    QMenu *startMenu = bar3->addMenu("帮助");
    //创建单项
    QAction * quitAction = startMenu->addAction("退出");
    //点击退出游戏
    connect(quitAction,&QAction::triggered,[=](){
        this->close();
    });
    //返回按钮
    MyPushButton *backBtn = new MyPushButton(":/new/prefix1/res/17.jpg",":/new/prefix1/res/18.jpg");
    backBtn->setParent(this);
    backBtn->move(1300,981);
    //点击返回
    connect(backBtn,&MyPushButton::clicked,[=](){
        if(QMessageBox::Yes == QMessageBox::question(this,"question","确定要退出吗？",QMessageBox::Yes|QMessageBox::No,QMessageBox::No)){
            for(int i=1;i<21;i++){
                for(int j=1;j<21;j++){
                    game->gameMapVec[i][j]=0;
                }
            }
            posrow=0;
            poscol=0;
            posrow_ex=0;
            poscol_ex=0;
            game->playerFlag=true;
            //延迟返回
            QTimer::singleShot(400,this,[=](){
                //返回主场景
                 emit this->chooseSceneBack();
            });
                }
    });
    MyPushButton *backBtn1 = new MyPushButton(":/new/prefix1/res/40.jpg",":/new/prefix1/res/41.jpg");
    backBtn1->setParent(this);
    backBtn1->move(1280,581);
    connect(backBtn1,&MyPushButton::clicked,[=](){
        int n(0);
        for(int row=0;row<21;row++){
            for(int col=0;col<21;col++){
                if(!game->gameMapVec[row][col]==0) n++;
            }
        }
        if(n){
               game->gameMapVec[posrow_ex][poscol_ex]=0;
                game->gameMapVec[posrow][poscol]=0;
                update();
        }
    });
     initGame();
}
void rjdzyjs::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/25.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
    painter.setRenderHint(QPainter::Antialiasing,true);
    for(int i=0;i<22;i++){
        //从左到右竖线
        painter.drawLine(55+52*i,55,55+52*i,1146);
        //从上到下横线
        painter.drawLine(55,55+52*i,1146,55+52*i);
    }
    //绘制选中点
    QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        // 绘制落子标记(防止鼠标出框越界)
        if (clickPosRow > 0 && clickPosRow < 21 &&
            clickPosCol > 0 && clickPosCol < 21 &&
            game->gameMapVec[clickPosRow][clickPosCol] == 0)
        {
            if (game->playerFlag)
                brush.setColor(Qt::black);
            else
                brush.setColor(Qt::white);
            painter.setBrush(brush);
            painter.drawRect(55 + 52 * clickPosCol - 6 / 2, 55 + 52 * clickPosRow - 6 / 2, 6, 6);
        }
        //绘制棋子
        for(int i=1;i<21;i++){
            for(int j=1;j<21;j++){
                if(i==posrow_ex&&j==poscol_ex){
                    if(game->gameMapVec[posrow_ex][poscol_ex]==1){
                        brush.setColor(Qt::black);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                    else {
                        brush.setColor(Qt::white);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                }
                else if(game->gameMapVec[i][j]==1){
                    brush.setColor(Qt::black);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
                else if(game->gameMapVec[i][j]==-1){
                    brush.setColor(Qt::white);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
            }
        }
        if (clickPosRow > 0 && clickPosRow < 21 &&
                    clickPosCol > 0 && clickPosCol < 21 &&
               (game->gameMapVec[clickPosRow][clickPosCol] == 1 ||
                        game->gameMapVec[clickPosRow][clickPosCol] == -1))
           {
               if (game->winorlose(clickPosRow, clickPosCol) && game->gameStatus == PLAYING)
               {
                        // qDebug() << "win";
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QString str;
                   if (game->gameMapVec[clickPosRow][clickPosCol] == 1)
                       str = "玩家获胜";
                   else if (game->gameMapVec[clickPosRow][clickPosCol] == -1)
                       str = "电脑获胜";
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", str );
                   // 重置游戏状态，否则容易死循环
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                   }
               }
               else if (game->heqi())
                   {
                       QMessageBox::StandardButton btnValue = QMessageBox::information(this, "啊偶", "和棋了");
                       if (btnValue == QMessageBox::Ok)
                       {
                           game->startGame(game_type);
                           game->gameStatus = PLAYING;
                       }
                   }
               else if (game->gameMapVec[clickPosRow][clickPosCol]==1&& game->nohands(clickPosRow,clickPosCol)){
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", "白棋获胜" );
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                   }
               }
           }
}
void rjdzyjs::initGame(){
    game = new GameModel;//初始化游戏模型
    initAIGame();
}
void rjdzyjs::initAIGame(){
    game_type=AIII;
    game->gameStatus=PLAYING;
    game->startGame(game_type);//在数据模型中进行初始化功能
    update();
}
void rjdzyjs::mouseMoveEvent(QMouseEvent *event)
{
    // 通过鼠标的hover确定落子的标记
    int x = event->x();
    int y = event->y();
    // 棋盘边缘不能落子
    if (x >= 55 +26&&
            x < 1121 &&
            y >= 55+26 &&
            y < 1121)
    {
        // 获取最近的左上角的点
        int col = (x-55) / 52;
        int row = (y-55) / 52;
        int leftTopPosX = 55 + 52 * col;
        int leftTopPosY = 55 + 52 * row;
        // 根据距离算出合适的点击位置,一共四个点，根据半径距离选最近的
        clickPosRow = -1; // 初始化最终的值
        clickPosCol = -1;
        int len = 0; // 计算完后取整就可以了
        selectPos =false;
        // 确定一个误差在范围内的点，且只可能确定一个出来
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
    }
    // 存了坐标后也要重绘
    update();
}
void rjdzyjs::mouseReleaseEvent(QMouseEvent *event){
    if(selectPos == false ){
        return ;
    }
    else{
        selectPos =false;
    }
    chessByPerson();
    if(game_type == AIII){
        QTimer::singleShot(1000, this, [=](){
            chessByAI();
        });
    }
}
void rjdzyjs::chessByPerson(){
    //根据当前存储的坐标落子
    //只有有效点击才下子，并且该处没有子
    if(clickPosRow !=-1&&clickPosCol!=-1&&game->gameMapVec[clickPosRow][clickPosCol]==0){
        for(int row=1;row<21;row++){
            for(int col=1;col<21;col++){
                if( game->gameMapVec[row][col]==0){
                    game->gameMapVec[row][col]=3;
                }
            }
        }
        posrow= clickPosRow;
        poscol= clickPosCol;
        game->Person(clickPosRow,clickPosCol);
        //重绘
        update();
    }
    //判断是否胜利
}
void rjdzyjs::chessByAI()
{
    for(int row=1;row<21;row++){
        for(int col=1;col<21;col++){
            if( game->gameMapVec[row][col]==3){
                game->gameMapVec[row][col]=0;
            }
        }
    }
    game->AI(clickPosRow, clickPosCol);
    posrow_ex=clickPosRow;
    poscol_ex=clickPosCol;
   update();
}

rjdzwjs.h中
#include"gamemodel.h"
#include <QMainWindow>
class rjdzwjs : public QMainWindow
{
    Q_OBJECT
public:
    explicit rjdzwjs(QWidget *parent = nullptr);
    //重新画背景图
    void paintEvent(QPaintEvent *);
    GameModel *game;//游戏指针
    GameType game_type;//存储游戏类型
    int clickPosRow,clickPosCol;    //存储将点击的位置
    bool selectPos = false;     //是否移动到合适的位置，以选中某个交叉点
    bool isWin;
    int posrow,poscol;
    int posrow_ex,poscol_ex;
    void initGame();
    void initAIGame();
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void chessByPerson();
     void chessByAI();
signals:
    //自定义信号 点击返回
   void chooseSceneBack();
public slots:
};

rjdzwjs.cpp中
#include "rjdzwjs.h"
#include<QMenuBar>
#include<QPainter>
#include"mypushbutton.h"
#include<QTimer>
#include<QMouseEvent>
#include<math.h>
#include"gamemodel.h"
#include<QDebug>
#include<QMessageBox>
rjdzwjs::rjdzwjs(QWidget *parent) : QMainWindow(parent)
{
     setMouseTracking(true);
    //配置基本信息
   this->setFixedSize(1406,1200);
   //设置图标
   this->setWindowIcon(QPixmap(":/new/prefix1/res/8.jpg"));
   //设置标题
   this->setWindowTitle("人机对战（无禁手）");
    //创建菜单栏
    QMenuBar *bar4 = menuBar();
    setMenuBar(bar4);
    //创建开始菜单
    QMenu *startMenu = bar4->addMenu("帮助");
    //创建单项
    QAction * quitAction = startMenu->addAction("退出");
    //点击退出游戏
    connect(quitAction,&QAction::triggered,[=](){
        this->close();
    });
    //返回按钮
    MyPushButton *backBtn = new MyPushButton(":/new/prefix1/res/17.jpg",":/new/prefix1/res/18.jpg");
    backBtn->setParent(this);
    backBtn->move(1300,981);
    //点击返回
    connect(backBtn,&MyPushButton::clicked,[=](){
        if(QMessageBox::Yes == QMessageBox::question(this,"question","确定要退出吗？",QMessageBox::Yes|QMessageBox::No,QMessageBox::No)){
            for(int i=1;i<21;i++){
                for(int j=1;j<21;j++){
                    game->gameMapVec[i][j]=0;
                }
            }
            posrow=0;
            poscol=0;
            posrow_ex=0;
            poscol_ex=0;
            game->playerFlag=true;
            //延迟返回
            QTimer::singleShot(400,this,[=](){
                //返回主场景
                 emit this->chooseSceneBack();
            });
                }
    });
    MyPushButton *backBtn1 = new MyPushButton(":/new/prefix1/res/40.jpg",":/new/prefix1/res/41.jpg");
    backBtn1->setParent(this);
    backBtn1->move(1280,581);
    connect(backBtn1,&MyPushButton::clicked,[=](){
        int n(0);
        for(int row=0;row<21;row++){
            for(int col=0;col<21;col++){
                if(!game->gameMapVec[row][col]==0) n++;
            }
        }
        if(n){
            game->gameMapVec[posrow_ex][poscol_ex]=0;
                game->gameMapVec[posrow][poscol]=0;
                update();
        }
    });
     initGame();
}
void rjdzwjs::paintEvent(QPaintEvent *){
    //创建画家，制定绘图设备
    QPainter painter(this);
    //创建QPixmap对象
    QPixmap pix;
    //加载图片
    pix.load(":/new/prefix1/res/26.jpg");
    //绘制背景图
    painter.drawPixmap(0,0,this->width(),this->height(),pix);
    painter.setRenderHint(QPainter::Antialiasing,true);
    for(int i=0;i<22;i++){
        //从左到右竖线
        painter.drawLine(55+52*i,55,55+52*i,1146);
        //从上到下横线
        painter.drawLine(55,55+52*i,1146,55+52*i);
    }
    //绘制选中点
    QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        // 绘制落子标记(防止鼠标出框越界)
        if (clickPosRow > 0 && clickPosRow < 21 &&
            clickPosCol > 0 && clickPosCol < 21 &&
            game->gameMapVec[clickPosRow][clickPosCol] == 0)
        {
            if (game->playerFlag)
                brush.setColor(Qt::black);
            else
                brush.setColor(Qt::white);
            painter.setBrush(brush);
            painter.drawRect(55 + 52 * clickPosCol - 6 / 2, 55 + 52 * clickPosRow - 6 / 2, 6, 6);
        }
        //绘制棋子
        for(int i=1;i<21;i++){
            for(int j=1;j<21;j++){
                if(i==posrow_ex&&j==poscol_ex){
                    if(game->gameMapVec[posrow_ex][poscol_ex]==1){
                        brush.setColor(Qt::black);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                    else {
                        brush.setColor(Qt::white);
                        painter.setBrush(brush);
                        painter.drawEllipse(55+52*j-25,55+52*i-25,50,50);
                    }
                }
                else if(game->gameMapVec[i][j]==1){
                    brush.setColor(Qt::black);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
                else if(game->gameMapVec[i][j]==-1){
                    brush.setColor(Qt::white);
                    painter.setBrush(brush);
                    painter.drawEllipse(55+52*j-20,55+52*i-20,40,40);
                }
            }
        }
        if (clickPosRow > 0 && clickPosRow < 21 &&
                    clickPosCol > 0 && clickPosCol < 21 &&
               (game->gameMapVec[clickPosRow][clickPosCol] == 1 ||
                        game->gameMapVec[clickPosRow][clickPosCol] == -1))
           {
               if (game->winorlose(clickPosRow, clickPosCol) && game->gameStatus == PLAYING)
               {
                        // qDebug() << "win";
                   for(int i=0;i<21;i++){
                               for(int j=0;j<21;j++){
                                   if(game->gameMapVec[i][j]==0)
                                   game->gameMapVec[i][j]=2;
                               }
                           }
                   game->gameStatus = WIN;
                   QString str;
                   if (game->gameMapVec[clickPosRow][clickPosCol] == 1)
                       str = "玩家获胜";
                   else if (game->gameMapVec[clickPosRow][clickPosCol] == -1)
                       str = "电脑获胜";
                   QMessageBox::StandardButton btnValue = QMessageBox::information(this, "恭喜", str );
                   // 重置游戏状态，否则容易死循环
                   if (btnValue == QMessageBox::Ok)
                   {
                            game->startGame(game_type);
                       game->gameStatus = PLAYING;
                   }
               }
               else if (game->heqi())
                   {
                       QMessageBox::StandardButton btnValue = QMessageBox::information(this, "啊偶", "和棋了");
                       if (btnValue == QMessageBox::Ok)
                       {
                           game->startGame(game_type);
                           game->gameStatus = PLAYING;
                       }
                   }
           }
}
void rjdzwjs::initGame(){
    game = new GameModel;//初始化游戏模型
    initAIGame();
}
void rjdzwjs::initAIGame(){
    game_type=AIII;
    game->gameStatus=PLAYING;
    game->startGame(game_type);//在数据模型中进行初始化功能
    update();
}
void rjdzwjs::mouseMoveEvent(QMouseEvent *event)
{
    // 通过鼠标的hover确定落子的标记
    int x = event->x();
    int y = event->y();
    // 棋盘边缘不能落子
    if (x >= 55 +26&&
            x < 1121 &&
            y >= 55+26 &&
            y < 1121)
    {
        // 获取最近的左上角的点
        int col = (x-55) / 52;
        int row = (y-55) / 52;
        int leftTopPosX = 55 + 52 * col;
        int leftTopPosY = 55 + 52 * row;
        // 根据距离算出合适的点击位置,一共四个点，根据半径距离选最近的
        clickPosRow = -1; // 初始化最终的值
        clickPosCol = -1;
        int len = 0; // 计算完后取整就可以了
        selectPos =false;
        // 确定一个误差在范围内的点，且只可能确定一个出来
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY) * (y - leftTopPosY));
        if (len < 20)
        {
            clickPosRow = row;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
        len = sqrt((x - leftTopPosX - 52) * (x - leftTopPosX - 52) + (y - leftTopPosY - 52) * (y - leftTopPosY - 52));
        if (len < 20)
        {
            clickPosRow = row + 1;
            clickPosCol = col + 1;
            if(game->gameMapVec[clickPosRow][clickPosCol]==0){
                selectPos = true;
            }
        }
    }
    // 存了坐标后也要重绘
    update();
}
void rjdzwjs::mouseReleaseEvent(QMouseEvent *event){
    if(selectPos == false ){
        return ;
    }
    else{
        selectPos =false;
    }
    chessByPerson();
    if(game_type == AIII){
        QTimer::singleShot(1000, this, [=](){
            chessByAI();
        });
    }
}
void rjdzwjs::chessByPerson(){
    //根据当前存储的坐标落子
    //只有有效点击才下子，并且该处没有子
    if(clickPosRow !=-1&&clickPosCol!=-1&&game->gameMapVec[clickPosRow][clickPosCol]==0){
        for(int row=1;row<21;row++){
            for(int col=1;col<21;col++){
                if( game->gameMapVec[row][col]==0){
                    game->gameMapVec[row][col]=3;         //不给点击其他位置
                }
            }
        }
        posrow= clickPosRow;
        poscol= clickPosCol;
        game->Person(clickPosRow,clickPosCol);
        //重绘
        update();
    }
}
void rjdzwjs::chessByAI()
{
    for(int row=1;row<21;row++){
        for(int col=1;col<21;col++){
            if( game->gameMapVec[row][col]==3){
                game->gameMapVec[row][col]=0;
            }
        }
    }
    game->AI(clickPosRow, clickPosCol);
    posrow_ex=clickPosRow;
    poscol_ex=clickPosCol;
   update();
}
